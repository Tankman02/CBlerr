# CBlerr — Всеобъемлющий гайд

Этот документ — единый, человеко‑читаемый мастер‑гайд по языку CBlerr и инструментам проекта. Здесь собраны ключевые концепции, практические примеры, инструкции по сборке и использованию GUI и компилятора — в одном месте, без ссылок на отдельные исходные гайды.

---

## Оглавление
- Быстрый старт
- Язык: основные концепции и синтаксис
- Типы, переменные и функции
- Управление потоком и структуры данных
- Указатели и управление памятью
- Работа с внешними функциями и GUI (Win32)
- Standalone‑компилятор и сборка (Windows / Linux / macOS)
- Что нового (v4.0) — кратко
- Полезные примеры
- Чит‑шит и часто задаваемые вопросы
- Дальше: экспорт, ревью и поддержка

---

## 1. Быстрый старт

1. Подготовьте окружение: Python 3.8+, компилятор C (GCC/MinGW/MSVC/Clang).
2. Для быстрого компилирования используйте интерактивный инструмент сборки или скрипты проекта.
3. Типовой цикл: написать файл с расширением `.cbl` → собрать в исполняемый файл → запустить.

Пример команды (Windows/PowerShell):

```powershell
python build/build_standalone.py program.cbl -o program.exe
```

На Linux/macOS:

```bash
python3 build/build_linux.py program.cbl -o program
```

---

## 2. Язык: основные концепции и синтаксис

- Статическая типизация: все переменные и параметры требуют указания типа.
- Синтаксис с отступами (рекомендуется 4 пробела).
- Доступны низкоуровневые конструкции: указатели, приведения типов, внешние C/WinAPI функции.
- Декораторы компиляции: `@comptime` (выполнение во время компиляции), `@packed`, `@inline`.

Пример функции:

```cbl
def add(a: i32, b: i32) -> i32:
	return a + b

def main() -> i32:
	print("Result:", add(2,3))
	return 0
```

---

## 3. Типы, переменные и функции

- Примитивы: `i8, i16, i32, i64`, `u8..u64`, `f32/float, f64`, `bool`, `str`.
- Объявление: `name: type = value`.
- Функции: `def name(params) -> returnType:`. Параметры обязаны иметь тип.

Пример:

```cbl
name: str = "CBlerr"
count: i32 = 10

def greet(n: str) -> void:
	print("Hi ", n)
```

---

## 4. Управление потоком и структуры данных

- Условия: `if`, `else`.
- Циклы: `while` (поддерживается `break` и `continue`).
- Структуры: `struct Name:` с перечислением полей.

Пример структуры и цикла:

```cbl
struct Point:
	x: i32
	y: i32

def sum_points(ps: *Point, n: i32) -> i32:
	total: i32 = 0
	i: i32 = 0
	while i < n:
		total = total + ps[i].x + ps[i].y
		i = i + 1
	return total
```

---

## 5. Указатели и управление памятью

- Синтаксис указателей: `*T` для указателя на `T`.
- Операции: `&x` — адрес, `*ptr` — разыменование.
- Динамическая память: вызовы `malloc`/`free` через `extern fn`.

Пример:

```cbl
extern fn malloc(size: u64) *void
extern fn free(ptr: *void) void

def example() -> void:
	arr: *i32 = malloc(10 * 4) as *i32
	arr[0] = 42
	free(arr)
```

---

## 6. Работа с внешними функциями и GUI (Win32)

- Поддерживаются внешние C функции и Win32 API через `extern fn`.
- Для GUI доступны вызовы создания окна, цикл обработки сообщений и GDI‑функции для рисования.

Минимальный пример окна и цикла сообщений (схема):

```cbl
extern fn CreateWindowExA(...) i32
extern fn ShowWindow(hWnd: i32, cmd: i32) i32
extern fn GetMessageA(msg: *void, hwnd: i32, w: i32, l: i32) i32
extern fn TranslateMessage(msg: *void) i32
extern fn DispatchMessageA(msg: *void) i32

def main() -> i32:
	hWnd = CreateWindowExA(...)
	ShowWindow(hWnd, 5)
	msg = malloc(64)
	while GetMessageA(msg, 0, 0, 0) != 0:
		TranslateMessage(msg)
		DispatchMessageA(msg)
	free(msg)
	return 0
```

---

## 7. Standalone‑компилятор и сборка

- Поддержка двух подходов сборки: "LLVM backend" и генерация C‑кода с последующей компиляцией (Standalone).
- Standalone режим генерирует C‑файл и вызывает системный компилятор (MinGW/GCC/MSVC/Clang) — результат: самодостаточный exe без зависимостей от LLVM.

Рекомендуемые команды:

Windows (через скрипт):
```powershell
python build/build_standalone.py source.cbl -o app.exe
```

Linux/macOS:
```bash
python3 build/build_linux.py source.cbl -o app
```

Makefile / скрипты позволяют автоматизировать сборку, проверку синтаксиса и вывод IR.

---

## 8. Что нового (v4.0) — кратко

- Встроенная функция `print()` для удобной отладки (компилируется в `printf`).
- Расширенная поддержка сборки для Linux (новые скрипты и Makefile).
- Улучшения UI‑библиотеки: persistent windows, event loop и GDI‑рисование.

---

## 9. Полезные примеры

- Простая функция и вызов:

```cbl
def add(a: i32, b: i32) -> i32:
	return a + b

def main() -> i32:
	print(add(1,2))
	return 0
```

- Работа со структурами и указателями показана в разделе выше.

---

## 10. Чит‑шит и часто задаваемые вопросы

- Частые ошибки: пропущенные типы, неверные отступы, отсутствие `:` после `def`/`if`/`while`.
- Как проверить синтаксис:

```bash
python compile_ui.py program.cbl --check
```

- Как получить IR:

```bash
python compile_ui.py program.cbl --ir
```

---

## 11. Дальше: экспорт, ревью и поддержка

Могу сделать одно из следующего (выберите):
- сгенерировать HTML и/или PDF из этого гида;
- нормализовать иерархию заголовков и добавить внутренние ссылки в оглавлении;
- выполнить орфографическую и стилистическую проверку;
- закоммитить файл в git и создать ветку/PR.

Файл обновлён: `c:\Users\User\Desktop\CBlerr\guides\COMBINED_GUIDE.md`

Если нужно — делаю выбранный шаг прямо сейчас.
